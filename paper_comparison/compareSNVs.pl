# compare the vcf files generated by true sequences to the result from VPhaser
# USAGE : perl compareSNVs.pl -gt "groundtruth.vcf" -mr "MultiRes.vcf file" OR -vp "VPhaser fdr file" OR -lf "LoFreq.vcf files" 
# -sh "SHorah output file" 
# -t Error threshold to only call variants if allele frequency is greater than x% (0.1 to 1) in MultiRes 
use Getopt::Long;

$VPhaser = "";
$groundT = "";
$MultiRes = "";
$LoFreq = "";
$ShoRAH = "";

$threshold=0;

GetOptions("vp:s",\$VPhaser, "gt=s",\$groundT,"mr:s",\$MultiRes,"lf:s",\$LoFreq,"sh:s",\$ShoRAH,"t:f",\$threshold);

main();

sub main
{
	loadgroundtruth();
	run_VPhaser() if $VPhaser ne "";
	run_MultiRes() if $MultiRes ne "";
	run_LoFreq() if $LoFreq ne "";
	run_ShoRAH() if $ShoRAH ne "";
}

sub loadgroundtruth
{
	open(file,$groundT);
	while($l=<file>)
	{
		chomp($l);
		if( substr($l,0,1) ne "#")
		{
			@vs = split(/\t/,$l);
			$pos = $vs[1];
			$pos_base{$pos}{$vs[3]} = 1;
			@alt_bases = split(/,/,$vs[4]);
			#@info = split(/;/,$vs[7]);
			#$depth = 0;
			#foreach $k(@info)
			#{
			#	if($k =~ /DP/)
			#	{
			#		($v,$depth) = split(/=/,$k);
			#	}
			#	if($k =~ /QS=/)
			#	{
			#		($v,$qsstring) = split(/=/,$k);
			#		@QS_bases = split(/,/,$qsstring);
			#	}
			#}
			for $k(@alt_bases)
			{
				if($k ne "<X>")
				{
					$pos_base{$pos}{$k} = 1;
				}
			}
			
		}
	}
	close file;
	# check_grountruth();
}

sub check_grountruth 
{
	for $pos(sort {$a<=>$b} keys %pos_base)
	{
		
		for $base(sort keys %{$pos_base{$pos}})
		{
			print "$pos\t";
			print $base."\n";
		}
	}
	
}

sub run_VPhaser
{
	##########################analyze the VPhaser file 
	open(file,$VPhaser);

	while($l=<file>)
	{
		chomp($l);
		if(substr($l,0,1) ne "#")
		{
			@vs = split(/\t/,$l);
			$pos = $vs[0];
			$alt = $vs[1];
			$ref = $vs[2];
			$vphaser_hash{$pos}{$ref} = 1;
		# ONly evaluate positions where snps are called 
			if($vs[4] eq "snp")
			{
				
				$vphaser_hash{$pos}{$alt} = 1;
			}
		}
	}
	close file;
	#for $pos(sort {$a<=>$b} keys %vphaser_hash)
	#{
	#	
	#	for $base(sort keys %{$vphaser_hash{$pos}})
	#	{
	#		print "$pos\t";
	#		print $base."\n";
	#	}
	#}
	#
	$true_pos = 0;
	$false_positive = 0;
	$false_negative  = 0;
	$total_vph = 0;
	$total_true = 0;
	$pos_notfound =0;
	#print "# STARTING COMPARISON \n";
	for $pos (sort {$a <=>$b} keys %pos_base)
	{
		$total_true += scalar(keys %{$pos_base{$pos}});
		if (scalar(keys %{$vphaser_hash{$pos}}) ==0)
		{
			# vphaser didn't call any variant, identical to reference
			$true_pos++;
			$total_vph++;
			$pos_notfound++;
			$false_negative += scalar(keys %{$pos_base{$pos}}) -1;
		}
		else
		{
			$total_vph+= scalar(keys %{$vphaser_hash{$pos}});
			for $base ( sort keys %{$pos_base{$pos}})
			{
				if(exists($vphaser_hash{$pos}{$base}))
				{
					$true_pos ++;
					#print "$pos\t$base\n";
				}
				else
				{
					# print "FN:$pos\t$base\n";
					$false_negative++;
				}
				#$total_vph++;
			}
		}
	}

	# Evaluate

	$recall = $true_pos/$total_true;
	$precision = $true_pos/$total_vph;
	$fpr = ($total_vph - $true_pos)/$true_pos;
	$diff = $total_vph - $true_pos;

	print "True pos $true_pos Total True $total_true Total VPh $total_vph PositionNF $pos_notfound FN $false_negative Precision $precision Recall $recall FP $diff FPR $fpr\n";
}

sub run_MultiRes
{
	open(file,$MultiRes);
	while($l=<file>)
	{
		chomp($l);
		if(substr($l,0,1) ne "#")
		{
			@vs = split(/\t/,$l);
			$pos = $vs[1];
			$ref = $vs[3];
			$MultiRes_hash{$pos}{$ref} = 1;
			@alt_bases = split(/,/,$vs[4]);
			# Gather information of from tests
			@info = split(/;/,$vs[7]);
			foreach $k(@info)
			{
				if($k =~ /QS=/)
				{
					($v,$qsstring) = split(/=/,$k);
					@QS_bases = split(/,/,$qsstring);
				}
			}
			# print "check $pos ".scalar(@alt_bases)."\n";
			for ($iter=0;$iter<scalar(@alt_bases);$iter++)
			{
				if ($alt_bases[$iter] ne "<X>")
				{
					if($QS_bases[$iter+1] > $threshold)
					{
						$MultiRes_hash{$pos}{$alt_bases[$iter]} = 1;	
					}
				}
			}
		}
	}
	close file;
	# for $pos(sort {$a<=>$b} keys %MultiRes_hash)
	# {
		
		# for $base(sort keys %{$MultiRes_hash{$pos}})
		# {
			# print "$pos\t";
			# print $base."\n";
		# }
	# }
	
	$true_pos = 0;
	$false_positive = 0;
	$false_negative  = 0;
	$total_vph = 0;
	$total_true = 0;
	$pos_notfound =0;
	for $pos (sort {$a <=>$b} keys %pos_base)
	{
		$total_true += scalar(keys %{$pos_base{$pos}});
		if (scalar(keys %{$MultiRes_hash{$pos}}) ==0)
		{
			# vphaser didn't call any variant, identical to reference
			$true_pos++;
			$total_vph++;
			$pos_notfound++;
			$false_negative += scalar(keys %{$pos_base{$pos}}) -1;
		}
		else
		{
			$total_vph+= scalar(keys %{$MultiRes_hash{$pos}});
			for $base ( sort keys %{$pos_base{$pos}})
			{
				if(exists($MultiRes_hash{$pos}{$base}))
				{
					$true_pos ++;
					#print "$pos\t$base\n";
				}
				else
				{
					#print "FN:$pos\t$base\n";
					$false_negative++;
				}
				#$total_vph++;
			}
		}
	}

	# Evaluate

	$recall = $true_pos/$total_true;
	$precision = $true_pos/$total_vph;
	$fpr = ($total_vph - $true_pos)/$true_pos;
	$diff = $total_vph - $true_pos;

	print "True pos $true_pos Total True $total_true Total MultiRes $total_vph PositionNF $pos_notfound FN $false_negative Precision $precision Recall $recall FP $diff FPR $fpr\n";
}


sub run_LoFreq
{
	open(file,$LoFreq);
	while($l=<file>)
	{
		chomp($l);
		if(substr($l,0,1) ne "#")
		{
			@vs = split(/\t/,$l);
			$pos = $vs[1];
			$ref = $vs[3];
			$LoFreq_hash{$pos}{$ref} = 1;
			@alt_bases = split(/,/,$vs[4]);
			for $k(@alt_bases)
			{
				if($k =~ /[AGCT]/)
				{
					# print "$pos $k\n";
					$LoFreq_hash{$pos}{$k} = 1;
				}
			}
		}
	}
	close file;
	# for $pos(sort {$a<=>$b} keys %LoFreq_hash)
	# {
		
		# for $base(sort keys %{$LoFreq_hash{$pos}})
		# {
			# print "$pos\t";
			# print $base."\n";
		# }
	# }	
	$true_pos = 0;
	$false_positive = 0;
	$false_negative  = 0;
	$total_vph = 0;
	$total_true = 0;
	$pos_notfound =0;
	for $pos (sort {$a <=>$b} keys %pos_base)
	{
		$total_true += scalar(keys %{$pos_base{$pos}});
		if (scalar(keys %{$LoFreq_hash{$pos}}) ==0)
		{
			# print "PosMissed $pos\n";
			# vphaser didn't call any variant, identical to reference
			$true_pos++;
			$total_vph++;
			$pos_notfound++;
			# print "NotFound: $pos ".keys(%{$pos_base{$pos}})."\n";
			$false_negative += scalar(keys %{$pos_base{$pos}}) -1;
		}
		else
		{
			$total_vph += scalar(keys %{$LoFreq_hash{$pos}});
			for $base ( sort keys %{$pos_base{$pos}})
			{
				if(exists($LoFreq_hash{$pos}{$base}))
				{
					$true_pos ++;
					# print "Found: $pos $base\n";
				}
				else
				{
					#print "FN:$pos\t$base\n";
					$false_negative++;
				}
				#$total_vph++;
			}
		}
	}

	# Evaluate

	$recall = $true_pos/$total_true;
	$precision = $true_pos/$total_vph;
	$fpr = ($total_vph - $true_pos)/$true_pos;
	$diff = $total_vph - $true_pos;

	print "True pos $true_pos Total True $total_true Total LF $total_vph PositionNF $pos_notfound FN $false_negative Precision $precision Recall $recall FP $diff FPR $fpr\n";

	
}

sub run_ShoRAH
{
	open(file, $shorah);
	while($l=<file>)
	{
		chomp($l);
		if($l !~ /Chromosome/)
		{
			@vs = split(/\t/,$l);
			$pos = $vs[1];
			$ref = $vs[2];
			$Shorah_Hash{$pos}{$ref} = 1;
			$alt = $vs[2];
			$Shorah_Hash{$pos}{$alt} = 1;
		}
	}
	close file;
	$true_pos = 0;
	$false_positive = 0;
	$false_negative = 0;
	$total_vph = 0;
	$total_true = 0;
	$pos_notfound = 0;
	for $pos (sort {$a<=>$b} keys %pos_base)
	{
		$total_true += scalar(keys %{$pos_base{$pos}});
		if (scalar(keys %{$Shorah_Hash{$pos}}) ==0)
		{
			# print "PosMissed $pos\n";
			# vphaser didn't call any variant, identical to reference
			$true_pos++;
			$total_vph++;
			$pos_notfound++;
			# print "NotFound: $pos ".keys(%{$pos_base{$pos}})."\n";
			$false_negative += scalar(keys %{$pos_base{$pos}}) -1;
		}
		else
		{
			$total_vph += scalar(keys %{$Shorah_Hash{$pos}});
			for $base ( sort keys %{$pos_base{$pos}})
			{
				if(exists($Shorah_Hash{$pos}{$base}))
				{
					$true_pos ++;
					# print "Found: $pos $base\n";
				}
				else
				{
					#print "FN:$pos\t$base\n";
					$false_negative++;
				}
				#$total_vph++;
			}
		}
	}

	$recall = $true_pos/$total_true;
	$precision = $true_pos/$total_vph;
	$fpr = ($total_vph - $true_pos)/$true_pos;
	$diff = $total_vph - $true_pos;

	print "True pos $true_pos Total True $total_true Total LF $total_vph PositionNF $pos_notfound FN $false_negative Precision $precision Recall $recall FP $diff FPR $fpr\n";

}
